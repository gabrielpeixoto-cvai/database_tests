\begin{section}{Implementação}
O objetivo do trabalho é utilizar as ferramentas da fabricante Altera em
conjunto com o\textit{software} Quartus II. O kit de desenvolvimento
EP2C35F672C6 da família Cyclone II, mostrado na Figura~\ref{fig:cyclone}, foi
utilizado como base do projeto. 

\begin{figure}[!h]
	\centering
	\includegraphics[width=.50\textwidth]{Figures/cyclone}
	\caption{DE Cyclone II EP2C35F672C6.}
	\label{fig:cyclone}
\end{figure}
A implementação do sistema foi feita em \emph{VHDL} no software 
\emph{QuartusII}, no qual foram impmentadas as rotinas de entrada/saída de dados
e todo o circuito lógico resposável por converter a entrada para complemento de
2, somar e produzir uma saída decimal.
O desenvolvimento do sistema se deu da forma mais intuitiva o possivel,
componentes simples foram combinados em componentes mais complexos.

\subsection{Entrada de Dados}
A entrada de dados foi pensada de uma forma paralela, pois as chaves da placa de
desenvolvimento \emph{DE2} poderiam ser usadas como entrada. Para tornar o
processamento dessa entrada interna mais fácil, os dados paralelos são
convertidos para uma saída vetorial.\\
%citar imagem com diagrama%
Há também outras entradas no sistema, como há a necessidade de se somarem 3
números, é preciso de duas chaves extras para seleção de saída de um
demultiplexador modificado para o projeto onde a lógica segue abaixo:

\begin{itemize}
    \item 00 - Primeiro número;
    \item 01 - Segundo número;
    \item 10 - Terceiro número;
    \item 11 - Zera todas as entradas.
\end{itemize}

Além das chaves de seleção há uma chave para ser usada como \emph{clock enable} 
do \emph{Flip-Flop D}, o qual é a memória do sitema.\\

Código de entrada de dados por chave:
\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/parallel2serial8.vhd}

Código de entrada de chaves de seleção:
\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/parallel2serial2.vhd}

Código do demultiplexador modificado para o sistema:
\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/demux3.vhd}


\subsection{Memória}
A memória do sistema é composta por 3 \emph{Flip-Flops D}, um para cada entrada.
Esses flip-flops necessitam de uma entrada de clock e uma de clock enable, como
explicado anteriormente, e irão guardar os dados até que seja dado o comando de
soma. A implementação é como, citada anteriormente, parte de um flip-flop de um
bit e depois implementa um de 8 bits como mostrado nos codigos-fonte abaixo:

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/flipflop.vhd}

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/flop8.vhd}



\subsection{Lógica}
A lógica do sistema consiste em:
\begin{itemize}
    \item Converter a entrada para binário em complemento de 2;
    \item Fazer a soma em complemento de 2;
    \item Desconverter o complemento de 2 para notação binária convencional;
    \item Converter a entrada binária para \emph{BCD (binary coded
    decimal)}.
\end{itemize}

\subsubsection{Bloco Complemento de 2}
A conversão em complemento de 2 como especificado em \ref{fig:complement2} é
realizada no código exemplificado abaixo:

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/2complement.vhd}

Foi necessário o uso de um clock para sincronia de entrada e saída nesse
bloco.\\

\subsubsection{Bloco Somador de 8 bits}
A soma com complemento de 2 segue o mesmo algoritmo de uma soma com números sem
sinal, mas na implementação do sistema deve-se salientar como o bloco somador
foi criado. Primeiramente, um bloco meio somador foi criado:

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/adder.vhd}

A partir de 2 meio somadores é possível implementar um somador completo:\\

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/fulladder.vhd}

E finalmente, usando 8 somadores completos em paralelo é possível implementar o
bloco somador de 8 bits do sistema. A linguagem VHDL permite usar uma clausula
\emph{generate} combinado com um \emph{loop} e mapeando a entrada vetorial para
cada porta de cada somador completo foi possivel criar um somador de 8 bits em
poucas linhas de código, tal como mostrado abaixo:\\

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/8bitadder.vhd}

\subsubsection{Bloco Desconversor de Complemento de 2}
Após o bloco somador é necessário converter o sinal gerado de volta para a
notação binária usual e separar o bit de sinal para ser usado na saída no
display. Esse bloco é simplesmente o Inverso do \emph{bloco de complemento de
2}, como explicitado abaixo:\\

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/deconv.vhd}

\subsubsection{Bloco Conversor BCD}

A conversão para BCD(\emph{Binary Doded Decimal}) é feita através do algoritmo
\emph{Double Dabble} como mostrado no código-fone abaixo:\\

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/bin2bcd.vhd}

\subsection{Saída de Dados}
A saída de dados é realizada através dos displays de 7 segmentos na placa
\ref{fig:cyclone}, onde basicamente, o bloco decodificador recebe o bit de
sinal e a saída do conversor BCD, a partir daí os binários são convertidos para
saídas nos displays como mostrado abaixo:\\

\lstinputlisting[language=VHDL]{/home/gaburiero/git/phi-fulladder/src/disp7_8bit.vhd}


\end{section}
%%% EOF %%%
